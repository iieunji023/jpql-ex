## 기본 문법과 쿼리 API

### 엔티티 생성
<details>
      <summary>Member.java</summary>

```
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    private String username;

    private int age;

    @ManyToOne
    @JoinColumn(name="TEAM_ID")
    private Team team;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

</details>
<details>
      <summary>Team.java</summary>

```
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

</details>
<details>
      <summary>Order.java</summary>

```
@Entity
@Table(name="ORDERS")
public class Order {
    @Id @GeneratedValue
    private Long id;

    private int orderAmount;

    @Embedded
    private Address address;

    @ManyToOne
    @JoinColumn(name="PRODUCT_ID")
    private Product product;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public int getOrderAmount() {
        return orderAmount;
    }

    public void setOrderAmount(int orderAmount) {
        this.orderAmount = orderAmount;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }
}

```

</details>
<details>
      <summary>Address.java</summary>

- 값 타입

```
@Embeddable
public class Address {
    private String city;

    private String street;

    private String zipcode;

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }

    public String getZipcode() {
        return zipcode;
    }

    public void setZipcode(String zipcode) {
        this.zipcode = zipcode;
    }
}

```

</details>

<details>
      <summary>⚠️ 테이블 생성 중 에러 발생</summary>

```
10:21:14.384 [main] WARN org.hibernate.tool.schema.internal.ExceptionHandlerLoggedImpl -- GenerationTarget encountered exception accepting command : Error executing DDL "
```

- 원인: Order 테이블이 예약어이므로, 따로 테이블명 지정해줘야 한다
- 해결방법

    ```
    @Entity
    @Table(name="ORDERS")
    public class Order {}
    ```

    - ORDER → ORDERS로 변경해주니 해결됨

</details>

### JPQL 문법

- select m from Member as m where m.age > 18
- 엔티티와 속성은 대소문자 구분O(Member, age)
    - 가지고 있는 객체와 동일하게 작성해야 함
- JPQL 키워드는 대소문자 구분X(SELECT, FROM, where)
- 엔티티 이름 사용, 테이블 이름 아님(Member)
- 별칭은 필수(m) (as는 생략 가능)

### 집합과 정렬

```
select
  COUNT**(m),  // 회원수**
  SUM**(m.age),  // 나이 합**
  AVG**(m.age)  // 평균 나이**
  MAX**(m.age)  // 최대 나이**
  MIN**(m.age) // 최소 나이**
from Member m
```

- GROUP BY, HAVING
- ORDER BY

### TypeQuery, Query

- TypeQuery: 반환 타입이 명확할 때 사용
- Query: 반환 타입이 명확하지 않을 때 사용

```
TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class);
TypedQuery<String> query = em.createQuery("select m.username, m.age from Member m", String.class);
Query query = em.createQuery("select m.username, m.age from Member m");
```

- Member 객체 전체를 조회하거나, `m.username`과 같이 String 타입만을 조회할 때는 `TypedQuery` 사용
- 그러나 `m.username`, `m.age` 등 타입이 다른 필드를 조회할 때는 `query`를 사용

### 결과 조회 API

- query.getResultList(): 결과가 하나 이상일 때, 리스트 반환
    - 결과가 없으면 빈 리스트 반환
        - NullPointException 발생하지 않음!
  - query.getSingleResult(): 결과가 정확히 하나, 단일 객체 반환
      - 결과가 없으면  javax.persistence.NoResultException
      - 둘 이상이면 javax.persistence.NonUniqueResultException
      - 따라서, 값이 정확히 하나만 반환될 때 사용해야 됨!!
      <details>
        <summary>예시</summary>

      ```
      TypedQuery<Member> query = em.createQuery("select m from Member m where m.id = 10", Member.class);
      Member result = query.getSingleResult();    // 값이 하나만 반환되는 경우, NullPoint Exception 발생 위험
    
      tx.commit();
      ```
      ```
      jakarta.persistence.NoResultException: No result found for query [select m from Member m where m.id = 10]
	    at org.hibernate.query.spi.AbstractSelectionQuery.getSingleResult(AbstractSelectionQuery.java:567)
      ```
        
      - NoResultException 발생
  
     </details>
    
### 파라미터 바인딩 - 이름 기준, 위치 기준

> 이름 기준

```
Member member = new Member();
member.setUsername("member1");
member.setAge(10);
em.persist(member);

Member result = em.createQuery("select m from Member m where m.username = :username", Member.class)
                   .setParameter("username", "member1")
                   .getSingleResult();

System.out.println("singleResult = " + result.getUsername());

tx.commit();
```

> 위치 기준

```
SELECT m FROM Member m where m.username=?1 
query.setParameter(1, usernameParam);
```

- 위치 기준은 사용XXX
- 중간에 다른 값이 들어오면 꼬일 위험 있음