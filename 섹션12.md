## 경로 표현식

- .(점)을 찍어 객체 그래프를 탐색하는 것

```
select **m.username**  // 상태 필드
from Member m
join **m.team** t  // 단일 값 연관 필드
join **m.orders** o  // 컬렉션 값 연관 필드
where t.name = '팀A'
```

### 경로 표현식 용어 정리

- 상태 필드(state field)
    - 단순히 값을 저장하기 위한 필드(ex. m.username)
- 연관 필드(association field)
    - 연관관계를 위한 필드
    1. 단일 값 연관 필드
        - `@ManyToOne`, `@OneToOne`, 대상이 엔티티(ex. m.team)
    2. 컬렉션 값 연관 필드
        - `@OneToMany`, `@ManyToMany`, 대상이 컬렉션(ex. m.orders)

### 경로 표현식 특징

> 상태 필드(state field)
<br> - 경로 탐색의 끝, 탐색 X

```
select m.username From Member m
```

> 단일 값 연관 경로
<br> - 묵시적 내부 조인(inner join) 발생, 탐색 O

- 묵시적 내부 조인 ⭐

    ```
    // 쿼리문
    select m.team From Member m
    
    // 출력결과
    Hibernate: 
        /* select
            m.team 
        From
            Member m */ select
                t1_0.id,
                t1_0.name 
            from
                Member m1_0 
            join
                Team t1_0 
                    on t1_0.id=m1_0.TEAM_ID
    ```

    - select문으로 작성했지만 내부 조인 발생
- 계속 탐색할 수 있다. (team 내의 필드 조회)

    ```
    select m.team.name From Member m
    ```


> 컬렉션 값 연관 경로
<br> - 묵시적 내부 조인 발생, 탐색X

```
select t.members From Team t
```

- 컬렉션 자체를 가리키기 때문에 필드를 찍는 등 더이상 탐색은 할 수 없음!
  (members 내의 username 탐색 불가)

```
select m.username From Team t join t.members m
```

- From절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

  (명시적 조인을 써야 쿼리 튜닝 등 유지보수 측면에서 좋음)


### 상태 필드 경로 탐색

- JPQL

    ```
    select m.username, m.age from Member m
    ```

- SQL

    ```
    select m.username, m.age from Member m
    ```


### 단일 값 연관 경로 탐색

- JPQL

    ```
    select o.member from Order o
    ```

- SQL

    ```
    select m.* from Order o inner join Member m on o.member_id = m.id
    ```


### 명시적 조인, 묵시적 조인

- 명시적 조인

    ```
    select m from Member m join m.team t
    ```

    - join 키워드 직접 사용
- 묵시적 조인

    ```
    select m.team from Member m
    ```

    - 경로 표현식에 의해 묵시적으로 SQL 조인 발생
      (내부 조인만 가능)

### 경로 탐색을 사용한 묵시적 조인 시 주의사항

- 항상 내부 조인
- 컬렉션은 경로 탐색의 끝, 명시적 조인을 통해 별칭을 얻어야 함
- 경로 탐색은 주로 SELECT, WHERE절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM (JOIN) 절에 영향을 줌
- **가급적 묵시적 조인 대신 명시적 조인 사용**
- 조인은 SQL 튜닝에 중요 포인트
- 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움

<br>

## 페치 조인 1 - 기본

조회할 때 많이 사용

실무에서 중요!!

- SQL 조인 종류 X
- JPQL에서 **성능 최적화**를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 **SQL 한번에 함께 조회**하는 기능
- join fetch 명령어 사용
- 페치 조인 ::=[LEFT [OUTER] | INNER ] JOIN FETCH 조인경로

### 엔티티 페치 조인

- 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한번에)
- SQL을 보면 회원 뿐만 아니라 **팀(T.*)**도 함께 **SELECT**
- [JPQL]
  select m from Member m **join fetch** m.team
- [SQL]
  SELECT M.*, **T.*** FROM MEMBER M **INNER JOIN TEAM** T ON M.TEAM_ID=T.ID
- **즉시로딩**으로 가져올 때와 동일

<img src="https://github.com/iieunji023/jpql-ex/blob/main/images/페치조인1.png" width="450"><br>
<img src="https://github.com/iieunji023/jpql-ex/blob/main/images/페치조인2.png" width="300">

### 실습

🔧 Member 조회(페치조인 사용 X)

<details>
      <summary>main.java</summary>

```
Team teamA = new Team();
teamA.setName("팀A");
em.persist(teamA);

Team teamB = new Team();
teamB.setName("팀B");
em.persist(teamB);

Member member1 = new Member();
member1.setUsername("회원1");
member1.setTeam(teamA);
em.persist(member1);

Member member2 = new Member();
member2.setUsername("회원2");
member2.setTeam(teamA);
em.persist(member2);

Member member3 = new Member();
member3.setUsername("회원3");
member3.setTeam(teamB);
em.persist(member3);

em.flush();
em.clear();

String query = "select m From Member m";
List<Member> result = em.createQuery(query, Member.class).getResultList();

for (Member member : result) {
     System.out.println("member= " + member.getUsername() + ", " + member.getTeam().getName());
     // 회원1, 팀A(SQL)
     // 회원2, 팀A(1차캐시)
     // 회원3, 팀B
}
            
tx.commit();
```

</details>
<details>
      <summary>쿼리 조회 결과</summary>

```
    /* select
        m 
    From
        Member m 
    join
        
    fetch
        m.team */ select
            m1_0.id,
            m1_0.age,
            t1_0.id,
            t1_0.name,
            m1_0.type,
            m1_0.username 
        from
            Member m1_0 
        join
            Team t1_0 
                on t1_0.id=m1_0.TEAM_ID
member= 회원1, 팀A
member= 회원2, 팀A
member= 회원3, 팀B
```

- 페치조인으로 회원과 팀을 함께 조회해서 지연로딩X
- JOIN할 때 member와 team 테이블 내의 컬럼을 모두 조회하므로 select문 한번만 날라감
- 지연로딩으로 세팅해도 페치조인이 항상 우선

</details>

💡 일대다 관계에서, 컬렉션 페치 조인을 실행해보자

- **[JPQL]** <br>
  select t from Team t join fetch t.members
  where t.name = ‘팀A’
- **[SQL]** <br>
  SELECT T.*, M.* FROM TEAMT
  INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
  WHERE T.NAME=’팀A’

<img src="https://github.com/iieunji023/jpql-ex/blob/main/images/페치조인3.png" width="500">

🔧 컬렉션 페치 조인 코드
```
String query = "select t From Team t join fetch t.members";
List<Team> result = em.createQuery(query, Team.class).getResultList();

for (Team team : result) {
     System.out.println("team= " + team.getName() + " |members= " + team.getMembers().size());
     for(Member member : team.getMembers()) {
          System.out.println("-> member = " + member);
     }
}
```
🔗 출력결과
```
team= 팀A |members= 2
-> member = Member{id=1, username='회원1', age=0}
-> member = Member{id=2, username='회원2', age=0}
team= 팀B |members= 1
-> member = Member{id=3, username='회원3', age=0}
```
- 일대다 컬렉션 페치 조인을 하면 팀A는 하나지만, 팀A에 소속된 회원이 2명이므로 size가 증가한다.

### 페치 조인과 일반 조인의 차이

- 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음
```
select t From Team t join t.members m
```

🔗 출력결과
```
Hibernate: 
    select
        m1_0.TEAM_ID,
        m1_0.id,
        m1_0.age,
        m1_0.type,
        m1_0.username 
    from
        Member m1_0 
    where
        m1_0.TEAM_ID=?
team= 팀A |members= 2
-> member = Member{id=1, username='회원1', age=0}
-> member = Member{id=2, username='회원2', age=0}
Hibernate: 
    select
        m1_0.TEAM_ID,
        m1_0.id,
        m1_0.age,
        m1_0.type,
        m1_0.username 
    from
        Member m1_0 
    where
        m1_0.TEAM_ID=?
team= 팀B |members= 1
-> member = Member{id=3, username='회원3', age=0}
```
- 일반 조인을 하면, 각 테이블에 대한 select문이 별도로 생성된다.

```
Hibernate: 
    /* select
        t 
    From
        Team t 
    join
        
    fetch
        t.members */ select
            t1_0.id,
            m1_0.TEAM_ID,
            m1_0.id,
            m1_0.age,
            m1_0.type,
            m1_0.username,
            t1_0.name 
        from
            Team t1_0 
        join
            Member m1_0 
                on t1_0.id=m1_0.TEAM_ID
team= 팀A |members= 2
-> member = Member{id=1, username='회원1', age=0}
-> member = Member{id=2, username='회원2', age=0}
team= 팀B |members= 1
-> member = Member{id=3, username='회원3', age=0}
```
- 페치 조인을 하게 되면 하나의 select문에 member, team 테이블의 컬럼을 모두 조회한다.

따라서, 페치 조인과 일반 조인의 차이는

- JPQL은 결과를 반환할 때 연관관계 고려X
- 단지 SELECT절에 지정한 엔티티만 조회할 뿐
- 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회X
- 페치 조인을 사용할 때만 연관된 엔티티도 함께 **조회(즉시 로딩)**
- **페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념**